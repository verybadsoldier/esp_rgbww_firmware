name: Publish_Firmware

on:
  workflow_run:
    workflows: ["firmwareBuild"]
    types: [completed]
  workflow_dispatch:
    inputs:
      branch:
        description: 'Branch to deploy'
        required: true
        default: 'develop'
        type: choice
        options:
          - stable
          - testing
          - develop

jobs:
  get-version:
    runs-on: ubuntu-latest
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    outputs:
      fw_version: ${{ steps.version.outputs.fw_version }}
      fw_branch: ${{ steps.version.outputs.fw_branch }}
      
    steps:
      - name: Get Branch
        id: get_branch
        run: |
          if [ "${{ github.event_name }}" == "workflow_dispatch" ]; then
            echo "branch=${{ github.event.inputs.branch }}" >> $GITHUB_OUTPUT
          else
            # For workflow_run events, get the branch from the triggering workflow
            triggering_branch=$(curl -s -H "Authorization: token ${{ secrets.artifact_download_token }}" \
              "https://api.github.com/repos/pljakobs/esp_rgbww_firmware/actions/runs/${{ github.event.workflow_run.id }}" | \
              jq -r '.head_branch')
            
            echo "Triggering workflow was on branch: $triggering_branch"
            echo "branch=$triggering_branch" >> $GITHUB_OUTPUT
          fi

      - name: Get Latest Successful Workflow Run
        id: get_run
        run: |
          latest_run_id=$(curl -s -H "Authorization: token ${{ secrets.artifact_download_token }}" \
            "https://api.github.com/repos/pljakobs/esp_rgbww_firmware/actions/runs?status=success" | \
            jq -r '.workflow_runs[] | select(.name == "firmwareBuild") | .id' | head -n 1)
          echo "latest_run_id=$latest_run_id" >> $GITHUB_OUTPUT
          echo "latest_run_id=$latest_run_id" >> $GITHUB_ENV
          
      - name: Download version info
        uses: actions/download-artifact@v4
        with:
          github-token: ${{ secrets.artifact_download_token }}
          run-id: ${{ env.latest_run_id }}
          name: version-info-${{ steps.get_branch.outputs.branch }}
          path: ./version-info
          
      - name: Load version info
        id: version
        run: |
          source ./version-info/version-info.txt
          echo "fw_version=$fw_version" >> $GITHUB_OUTPUT
          echo "fw_branch=$fw_branch" >> $GITHUB_OUTPUT

  publish:
    runs-on: ubuntu-latest
    needs: get-version
    if: ${{ github.event.workflow_run.conclusion == 'success' || github.event_name == 'workflow_dispatch' }}
    
    steps:
      - name: Checkout gh-pages branch
        uses: actions/checkout@v3
        with:
          ref: gh-pages
          
      # Checkout main repository to get manage_version.py
      - name: Checkout main repository
        uses: actions/checkout@v3
        with:
          path: esp_firmware_repo
          
      # Create Jekyll config to exclude download directory
      - name: Create Jekyll config
        run: |
          cat > _config.yml << EOF
exclude:
  - download
  - esp_firmware_repo
EOF
          
      # Create download directories for all branches (with version)
      - name: Create directories
        run: |
          branch="${{ needs.get-version.outputs.fw_branch }}"
          version="${{ needs.get-version.outputs.fw_version }}"
          # Create versioned directory structure
          for soc in esp8266 esp32 esp32c3; do
            mkdir -p download/$branch/$version/$soc/debug
            mkdir -p download/$branch/$version/$soc/release
            mkdir -p download/$branch/$version/$soc/debug/single_image
            mkdir -p download/$branch/$version/$soc/release/single_image
          done
          
          # Create version.txt file instead of symlink
          mkdir -p download/$branch/latest
          echo "$version" > download/$branch/latest/version.txt
          echo "<html><head><meta http-equiv=\"refresh\" content=\"0; URL=../$version/\"></head></html>" > download/$branch/latest/index.html
          
      # Download artifacts for the current branch
      - name: Download artifacts
        run: |
          branch="${{ needs.get-version.outputs.fw_branch }}"
          version="${{ needs.get-version.outputs.fw_version }}"
          latest_run_id=$(curl -s -H "Authorization: token ${{ secrets.artifact_download_token }}" \
            "https://api.github.com/repos/pljakobs/esp_rgbww_firmware/actions/runs?status=success" | \
            jq -r '.workflow_runs[] | select(.name == "firmwareBuild") | .id' | head -n 1)
          echo "latest_run_id=$latest_run_id" >> $GITHUB_ENV
          
          # Define all combinations for artifact downloads with version in path
          combinations=(
            "esp8266 debug 0 download/$branch/$version/esp8266/debug"
            "esp8266 release 0 download/$branch/$version/esp8266/release"
            "esp32 debug 0 download/$branch/$version/esp32/debug"
            "esp32 release 0 download/$branch/$version/esp32/release"
            "esp32c3 debug 0 download/$branch/$version/esp32c3/debug"
            "esp32c3 release 0 download/$branch/$version/esp32c3/release"
            "esp8266 debug 1 download/$branch/$version/esp8266/debug/single_image"
            "esp8266 release 1 download/$branch/$version/esp8266/release/single_image"
            "esp32 debug 1 download/$branch/$version/esp32/debug/single_image"
            "esp32 release 1 download/$branch/$version/esp32/release/single_image"
            "esp32c3 debug 1 download/$branch/$version/esp32c3/debug/single_image"
            "esp32c3 release 1 download/$branch/$version/esp32c3/release/single_image"
          )
          
          for combo in "${combinations[@]}"; do
            read -r soc build_type single_img path <<< "$combo"
            
            # Determine artifact name
            if [ "$single_img" = "1" ]; then
              tag="-single_image"
            else
              tag=""
            fi
            
            if [ "$build_type" = "release" ]; then
              artifact_name="lightinator-${soc}-release${tag}-${branch}"
            else
              artifact_name="lightinator-${soc}-debug${tag}-${branch}"
            fi
            
            echo "Downloading $artifact_name to $path"
            
            # Create directory and download
            mkdir -p "$path"
            
            # Download the artifact - continue on errors
            curl -s -H "Authorization: token ${{ secrets.artifact_download_token }}" \
              -o /tmp/artifact_list.json \
              "https://api.github.com/repos/pljakobs/esp_rgbww_firmware/actions/runs/${{ env.latest_run_id }}/artifacts"
            
            artifact_url=$(cat /tmp/artifact_list.json | jq -r ".artifacts[] | select(.name == \"$artifact_name\") | .archive_download_url")
            
            if [ -n "$artifact_url" ]; then
              curl -L -H "Authorization: token ${{ secrets.artifact_download_token }}" \
                -o "$path/artifact.zip" "$artifact_url"
              
              # Extract the artifact if download was successful
              if [ -f "$path/artifact.zip" ]; then
                unzip -q -o "$path/artifact.zip" -d "$path"
                rm "$path/artifact.zip"
              else
                echo "Failed to download $artifact_name"
              fi
            else
              echo "No artifact named $artifact_name found"
            fi
          done
      
      # Download version.json from lightinator.de if it doesn't exist locally
      - name: Get version.json
        run: |
          if [ ! -f "version.json" ]; then
            echo "Downloading version.json from lightinator.de"
            curl -L -o version.json https://lightinator.de/version.json
            if [ ! -f "version.json" ] || [ ! -s "version.json" ]; then
              echo "Failed to download version.json, creating a new one"
              python3 esp_firmware_repo/manage_version.py version.json add esp8266 release stable "V5.0-init-stable" "http://lightinator.de/download/stable/V5.0-init-stable/esp8266/release/rom0.bin"
            fi
          fi
          
      # Update version.json using the manage_version.py script
      - name: Update version.json
        run: |
          branch="${{ needs.get-version.outputs.fw_branch }}"
          version="${{ needs.get-version.outputs.fw_version }}"
          deploy_server="lightinator.de"
          
          # Define all combinations to update - only for non-single-image builds
          for soc in esp8266 esp32 esp32c3; do
            for type in debug release; do
              # Determine correct file path based on soc
              if [ "$soc" = "esp8266" ]; then
                file="rom0.bin"
              else
                file="app.bin"
              fi
              
              # Update entry in version.json with versioned path
              url="http://$deploy_server/download/$branch/$version/$soc/$type/$file"
              python3 esp_firmware_repo/manage_version.py version.json add $soc $type $branch "$version" "$url"
              
              # We're not adding single image entries to version.json per requirements
            done
          done
          
      - name: Commit and push changes
        run: |
          git config user.name "GitHub Actions"
          git config user.email "actions@github.com"
          git add .
          git commit -m "Publish firmware for ${{ needs.get-version.outputs.fw_branch }} branch, version ${{ needs.get-version.outputs.fw_version }}" || echo "No changes to commit"
          git push origin gh-pages
          
      # Setup and deploy to your external server
      - name: Setup SSH and deploy
        uses: webfactory/ssh-agent@v0.7.0
        with:
          ssh-private-key: ${{ secrets.DEPLOY_KEY }}
          
      - name: Configure variables
        run: |
          echo "deploy_user=github-deploy" >> $GITHUB_ENV
          echo "deploy_server=lightinator.de" >> $GITHUB_ENV
          echo "deploy_path=~/nginx/html" >> $GITHUB_ENV
          
      - name: Add server to known_hosts
        run: |
          ssh-keyscan ${{ env.deploy_server }} >> ~/.ssh/known_hosts
          
      - name: Deploy to External Server
        run: |
          branch="${{ needs.get-version.outputs.fw_branch }}"
          version="${{ needs.get-version.outputs.fw_version }}"
          
          # Create directories with version in path
          for soc in esp8266 esp32 esp32c3; do
            ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "mkdir -p ${{ env.deploy_path }}/download/$branch/$version/$soc/debug"
            ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "mkdir -p ${{ env.deploy_path }}/download/$branch/$version/$soc/release"
            ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "mkdir -p ${{ env.deploy_path }}/download/$branch/$version/$soc/debug/single_image"
            ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "mkdir -p ${{ env.deploy_path }}/download/$branch/$version/$soc/release/single_image"
            
            # Copy files with version in path
            scp -r download/$branch/$version/$soc/debug/* ${{ env.deploy_user }}@${{ env.deploy_server }}:${{ env.deploy_path }}/download/$branch/$version/$soc/debug/ || true
            scp -r download/$branch/$version/$soc/release/* ${{ env.deploy_user }}@${{ env.deploy_server }}:${{ env.deploy_path }}/download/$branch/$version/$soc/release/ || true
            
            # Copy single image files if they exist
            if [ -d "download/$branch/$version/$soc/debug/single_image" ] && [ "$(ls -A download/$branch/$version/$soc/debug/single_image)" ]; then
              scp -r download/$branch/$version/$soc/debug/single_image/* ${{ env.deploy_user }}@${{ env.deploy_server }}:${{ env.deploy_path }}/download/$branch/$version/$soc/debug/single_image/ || true
            fi
            
            if [ -d "download/$branch/$version/$soc/release/single_image" ] && [ "$(ls -A download/$branch/$version/$soc/release/single_image)" ]; then
              scp -r download/$branch/$version/$soc/release/single_image/* ${{ env.deploy_user }}@${{ env.deploy_server }}:${{ env.deploy_path }}/download/$branch/$version/$soc/release/single_image/ || true
            fi
          done
          
          # Create version file and redirect instead of symlink
          ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "mkdir -p ${{ env.deploy_path }}/download/$branch/latest && \
            echo \"$version\" > ${{ env.deploy_path }}/download/$branch/latest/version.txt && \
            echo '<html><head><meta http-equiv=\"refresh\" content=\"0; URL=../'$version'/\"></head></html>' > ${{ env.deploy_path }}/download/$branch/latest/index.html"
          
          # Replace placeholders and upload version.json
          sed <version.json -e "s/%host%/http:\/\/${{ env.deploy_server }}/" | ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "cat >${{ env.deploy_path }}/version.json"
          
      - name: Change ownership of uploaded files
        run: |
          ssh ${{ env.deploy_user }}@${{ env.deploy_server }} "chown -R github-deploy:nginx ${{ env.deploy_path }}/*"